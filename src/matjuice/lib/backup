/**
     * Convert an access into an array into a JavaScript function call.
     *
     * A(i, j, k)  ==>  mc_array_get(A, [i, j, k])
     *
     * @param expr a Parametrized expression where the name corresponds to a
     * matrix kind.
     * @return the JavaScript function call.
     */
    private Expr genArrayGetExpr(ast.ParameterizedExpr expr, TIRCommaSeparatedList targets) {
        // Check whether we are indexing a single element or a slice.
        boolean has_colons = false;
        for (int i = 0; i < expr.getNumArg(); ++i) {
            has_colons = has_colons || isColonExpr(expr.getArg(i));
        }

        // Common case: all the indices are scalars.  Generate a call to mc_array_get and return.
        if (!has_colons) {
            return genSingleElementIndexing(expr);
        }

        // Less-common, but more general case: some indices are colon expressions.
        // Step 1: create the indices array, converting scalars to colon expressions (i.e. k -> k:k)
        ExprArray indices = new ExprArray();
        for (int i = 0; i < expr.getNumArg(); ++i) {
            // Add a colon-expression (converting scalar expressions if necessary) to the indices array.
            ast.Expr indexing_expr = expr.getArg(i);
            if (isColonExpr(indexing_expr)) {
                indices.addValue(genExpr(indexing_expr));
            }
            else {
                Expr scalar_index = genExpr(indexing_expr);
                Expr colon_index = convertToColonExpr(scalar_index);
                indices.addValue(colon_index);
            }
        }

        // Step 2: create dimensions and resulting length parameters.
        // If they cannot be computed statically, they will be
        // computed at runtime.
        ExprArray dimensions = new ExprArray();
        boolean size_known_statically = true;
        int result_size = 1;
        AggrValue<BasicMatrixValue> singleton = analysis.getCurrentOutSet().get(targets.getName(0).getID()).getSingleton();
        BasicMatrixValue val = (BasicMatrixValue) singleton;
        for (DimValue dv: val.getShape().getDimensions()) {
            Integer curr_dim = dv.getIntValue();
            size_known_statically = size_known_statically && (curr_dim != null);
            dimensions.addValue(curr_dim != null ? new ExprInt(dv.getIntValue()) : new ExprVar("null"));
            if (size_known_statically) {
                result_size *= dv.getIntValue();
            }
        }

        // Step 3: create a call.
        // TODO(vfoley1): do we want indices.getNumValue(), dimensions.getNumValue()? maybe both?
        int numSlices = indices.getNumValue();
        if (size_known_statically && (numSlices == 1 || numSlices == 2)) {
            return new ExprCall(
                    new ExprVar("mc_array_slice_static_" + numSlices),
                    new List<Expr>(genExpr(expr.getTarget()), new ExprInt(result_size), dimensions, indices)
                    );
        }
        else if (numSlices == 1 || numSlices == 2) {
            return new ExprCall(
                    new ExprVar("mc_array_slice_dynamic_" + numSlices),
                    new List<Expr>(genExpr(expr.getTarget()), dimensions, indices)
                    );
        }
        else if (size_known_statically) {
            return new ExprCall(
                    new ExprVar("mc_array_slice_static"),
                    new List<Expr>(genExpr(expr.getTarget()), new ExprInt(result_size), dimensions, indices)
                    );
        }
        else {
            return new ExprCall(
                    new ExprVar("mc_array_slice_dynamic"),
                    new List<Expr>(genExpr(expr.getTarget()), new ExprInt(numSlices), indices)
                    );
        }
    }
