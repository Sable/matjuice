/*
 *  Copyright 2014-2015, Vincent Foley-Bourgon, McGill University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */


import matjuice.pretty.Pretty;
import matjuice.pretty.PrettyBase;

aspect PrettyPrinter {

    public PrettyBase Program.pp() {
        PrettyBase[] ppFunctions = new PrettyBase[this.getNumFunction()];
        int i = 0;
        for (Function f: this.getFunctionList()) {
            ppFunctions[i] = f.pp();
            i++;
        }
        return Pretty.separateBy(Pretty.concat(Pretty.NEWLINE, Pretty.NEWLINE),
                                 ppFunctions);
    }

    public PrettyBase Function.pp() {
        // Formal parameters
        PrettyBase[] ppParams = new PrettyBase[this.getNumParam()];
        int i = 0;
        for (Parameter param: this.getParamList()) {
            ppParams[i] = param.pp();
            ++i;
        }

        return Pretty.concat(Pretty.text("function "),
                             this.hasFunctionName() ? this.getFunctionName().pp() : Pretty.EMPTY,
                             Pretty.argList(ppParams),
                             Pretty.text(" "),
                             this.getStmtBlock().pp());


    }

    public PrettyBase FunctionName.pp() {
        return Pretty.text(this.getName());
    }


    public PrettyBase Parameter.pp() {
        return Pretty.text(this.getName());
    }

    public PrettyBase Stmt.pp() {
        return Pretty.text("STMT SHOULD NOT BE GENERATED");
    }

    public PrettyBase StmtExpr.pp() {
        return Pretty.concat(this.getExpr().pp(), Pretty.text(";"));
    }

    public PrettyBase StmtReturn.pp() {
        return Pretty.concat(Pretty.text("return "),
                             this.hasExpr() ? this.getExpr().pp() : Pretty.EMPTY,
                             Pretty.text(";"));
    }


    public PrettyBase StmtBlock.pp() {
        PrettyBase[] stmts = new PrettyBase[this.getNumStmt()];
        int i = 0;
        for (Stmt stmt: this.getStmtList()) {
            stmts[i++] = stmt.pp();
        }
        if (this.getBraces())
            return Pretty.block(stmts);
        else
            return Pretty.separateBy(Pretty.NEWLINE, stmts);
    }

    public PrettyBase StmtIfThenElse.pp() {
        return Pretty.concat(
            Pretty.text("if "), Pretty.parenthesized(this.getCond().pp()), Pretty.text(" "),
            this.getThen().pp(),
            this.getElse().getNumStmt() == 0
            ? Pretty.EMPTY
            : Pretty.concat(Pretty.NEWLINE, Pretty.text("else "), this.getElse().pp())
            );
    }


    public PrettyBase StmtWhile.pp() {
        return Pretty.separateBy(
            Pretty.text(" "),
            Pretty.text("while"),
            Pretty.parenthesized(this.getCond().pp()),
            this.getBody().pp());
    }


    public PrettyBase StmtFor.pp() {
        PrettyBase init = this.getInit().pp();
        PrettyBase test = this.getTest().pp();
        PrettyBase upd  = this.getUpdate().pp();
        return Pretty.separateBy(
            Pretty.text(" "),
            Pretty.text("for"),
            Pretty.parenthesized(Pretty.separateBy(Pretty.text("; "), init, test, upd)),
            this.getBody().pp());
    }


    public PrettyBase StmtVarDecl.pp() {
        PrettyBase init =
            this.hasInit()
            ? Pretty.concat(Pretty.text(" = "), this.getInit().pp())
            : Pretty.EMPTY;
        return Pretty.concat(Pretty.text("var "), Pretty.text(this.getId()), init, Pretty.text(";"));
    }

    public PrettyBase StmtComment.pp() {
        return Pretty.concat(Pretty.text("// "),
                             Pretty.text(this.getText()));
    }


    public PrettyBase StmtEmpty.pp() {
        return Pretty.EMPTY;
    }


    public PrettyBase StmtBreak.pp() {
        return Pretty.text("break");
    }


    public PrettyBase StmtContinue.pp() {
        return Pretty.text("continue");
    }



    public PrettyBase Expr.pp() {
        return Pretty.text("EXPR SHOULD NOT BE GENERATED");
    }

    public PrettyBase ExprInt.pp() {
        return Pretty.text(this.getValue() + "");
    }

    public PrettyBase ExprFloat.pp() {
        return Pretty.text(this.getValue() + "");
    }

    public PrettyBase ExprBoolean.pp() {
        return Pretty.text(this.getValue() + "");
    }

    // FIXME: handle escaping.
    public PrettyBase ExprString.pp() {
        return Pretty.text('"' + this.getValue() + '"');
    }

    public PrettyBase ExprArray.pp() {
        PrettyBase[] exprs = new PrettyBase[this.getNumExpr()];
        int i = 0;
        for (Expr expr: this.getExprList()) {
            exprs[i] = expr.pp();
            ++i;
        }

    	return Pretty.concat(
            Pretty.text("["),
            Pretty.separateBy(Pretty.text(", "), exprs),
            Pretty.text("]")
    	);
    }

    public PrettyBase ExprId.pp() {
        return Pretty.text(this.getName());
    }


    public PrettyBase ExprPropertyGet.pp() {
        return Pretty.concat(this.getExpr().pp(),
                             Pretty.wrapped(Pretty.text("["),
                                            Pretty.text("]"),
                                            this.getProperty().pp()));
    }

    public PrettyBase ExprCall.pp() {
        PrettyBase[] args = new PrettyBase[this.getNumArgument()];
        int i = 0;
        for (Expr arg : this.getArgumentList()) {
            args[i] = arg.pp();
            ++i;
        }
        return Pretty.concat(this.getExpr().pp(),
                             Pretty.argList(args));
    }

    public PrettyBase ExprUnaryOp.pp() {
        return Pretty.concat(Pretty.text(this.getOp()),
                             this.getExpr().pp());
    }

    public PrettyBase ExprBinaryOp.pp() {
        return Pretty.concat(
            Pretty.text("("),
            this.getLHS().pp(),
            Pretty.text(" "),
            Pretty.text(this.getOp()),
            Pretty.text(" "),
            this.getRHS().pp(),
            Pretty.text(")")
            );
    }

    public PrettyBase ExprAssign.pp() {
        return Pretty.concat(this.getLHS().pp(),
                             Pretty.text(" = "),
                             this.getRHS().pp());
    }

    public PrettyBase ExprTernary.pp() {
        return Pretty.separateBy(
            Pretty.text(" "),
            this.getExpr().pp(),
            Pretty.text("?"),
            this.getThenExpr().pp(),
            Pretty.text(":"),
            this.getElseExpr().pp()
            );
    }

    public PrettyBase ExprColon.pp() {
        return Pretty.text("MC_COLON");
    }
}
