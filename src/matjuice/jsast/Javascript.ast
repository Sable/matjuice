/*
 *  Copyright 2014-2015, Vincent Foley-Bourgon, McGill University
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

Program ::= Function:Function*;
Function ::= <FunctionName:String> Param:Identifier* Decls:Identifier* Stmt:Stmt*;
Identifier ::= <Id:String>;


abstract Stmt;
StmtAssign:Stmt   ::= <Lhs:String> Rhs:Expr;                               // lhs = rhs;
StmtGet:Stmt      ::= <Lhs:String> <Rhs:String> Index:Expr;                // lhs = rhs[expr];
StmtSet:Stmt      ::= <Lhs:String> Index:Expr <Rhs:String>;                // lhs[expr] = rhs;
StmtUnop:Stmt     ::= <Lhs:String> Op:Unop <Rhs:String>;                   // lhs = op rhs;
StmtBinop:Stmt    ::= <Lhs:String> Op:Binop <Rhs1:String> <Rhs2:String>;   // lhs = rhs1 op rhs2;
StmtCall:Stmt     ::= <Lhs:String> <Function:String> Argument:Identifier*; // lhs = function(arg1, arg2, ..., argk);
StmtIf:Stmt       ::= <Condition:String> ThenStmt:Stmt* ElseStmt:Stmt*;    // if (condition) { thenStmt } else { elseStmt }
StmtWhile:Stmt    ::= <Condition:String> BodyStmt:Stmt*;                   // while (condition) { bodyStmt }
StmtReturn:Stmt   ::= Return:Identifier*;                                  // return [ret1, ret2, ..., retk]
StmtBreak:Stmt;                                                            // break;
StmtContinue:Stmt;                                                         // continue;
StmtSequence:Stmt ::= Stmt:Stmt*;                                          // Multiple statements to allow for one Tamer statement to generate multiple JS statements.

abstract Expr;
ExprNum:Expr  ::= <Value:Double>; // 3, 3.141592
ExprId:Expr   ::= <Value:String>; // id

abstract Unop;
UnopNegate:Unop;
UnopNot:Unop;

abstract Binop;
BinopAdd:Binop;
BinopSub:Binop;
BinopMul:Binop;
BinopDiv:Binop;
BinopMod:Binop;
BinopEq:Binop;
BinopNe:Binop;
BinopLt:Binop;
BinopLe:Binop;
BinopGt:Binop;
BinopGe:Binop;
